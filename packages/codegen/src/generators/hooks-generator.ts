// ============================================================
// Hooks Generator — Generate data-fetching hooks from dataSources
// ============================================================

import type { PageSchema, PageSchemaDataSource } from '@neuron-ui/metadata'
import type { HooksStyle, ApiClientStyle } from '../types'
import { toPageComponentName, toHookName, parseApiString } from '../utils/naming'

/**
 * Generate a hooks file (.hooks.ts) from a PageSchema's dataSources.
 */
export function generateHooksFile(
  schema: PageSchema,
  style: HooksStyle = 'hooks',
  apiClient: ApiClientStyle = 'fetch',
): string {
  const pageName = toPageComponentName(schema.page.name)
  const dataSources = schema.dataSources ?? {}
  const entries = Object.entries(dataSources)

  if (entries.length === 0) {
    return `// ${pageName}.hooks.ts — No data sources defined\nexport {}\n`
  }

  const lines: string[] = []

  // File header
  lines.push(`// ${pageName}.hooks.ts`)
  lines.push(`// Auto-generated by @neuron-ui/codegen — do not edit manually`)
  lines.push('')

  // Imports based on style
  lines.push(...generateImports(style, apiClient, entries))
  lines.push('')

  // Generate a hook for each dataSource
  for (const [key, ds] of entries) {
    const { method, path: apiPath } = parseApiString(ds.api)
    const isQuery = method === 'GET'

    if (isQuery) {
      lines.push(...generateQueryHook(key, ds, apiPath, style, apiClient))
    } else {
      lines.push(...generateMutationHook(key, ds, method, apiPath, style, apiClient))
    }
    lines.push('')
  }

  return lines.join('\n')
}

// ---- Import generation ----

function generateImports(
  style: HooksStyle,
  apiClient: ApiClientStyle,
  entries: Array<[string, PageSchemaDataSource]>,
): string[] {
  const lines: string[] = []

  const hasQueries = entries.some(([, ds]) => {
    const { method } = parseApiString(ds.api)
    return method === 'GET'
  })

  const hasMutations = entries.some(([, ds]) => {
    const { method } = parseApiString(ds.api)
    return method !== 'GET'
  })

  switch (style) {
    case 'hooks':
      lines.push(`import { useState, useEffect, useCallback } from 'react'`)
      break
    case 'swr': {
      const swrImports: string[] = []
      if (hasQueries) swrImports.push('useSWR')
      if (hasMutations) swrImports.push('useSWRMutation')
      lines.push(`import { ${swrImports.join(', ')} } from 'swr'`)
      break
    }
    case 'react-query': {
      const rqImports: string[] = []
      if (hasQueries) rqImports.push('useQuery')
      if (hasMutations) rqImports.push('useMutation', 'useQueryClient')
      lines.push(
        `import { ${rqImports.join(', ')} } from '@tanstack/react-query'`,
      )
      break
    }
  }

  // API client imports (only for axios/ky)
  if (apiClient === 'axios') {
    lines.push(`import axios from 'axios'`)
  } else if (apiClient === 'ky') {
    lines.push(`import ky from 'ky'`)
  }

  return lines
}

// ---- Fetcher expression helpers ----

function fetcherExpression(apiPath: string, apiClient: ApiClientStyle): string {
  switch (apiClient) {
    case 'fetch':
      return `fetch('${apiPath}').then((res) => res.json())`
    case 'axios':
      return `axios.get('${apiPath}').then((res) => res.data)`
    case 'ky':
      return `ky.get('${apiPath}').json()`
  }
}

function mutationExpression(
  method: string,
  apiPath: string,
  apiClient: ApiClientStyle,
): string {
  const lowerMethod = method.toLowerCase()
  switch (apiClient) {
    case 'fetch':
      return `fetch('${apiPath}', { method: '${method}', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) }).then((res) => res.json())`
    case 'axios':
      if (method === 'DELETE') {
        return `axios.${lowerMethod}('${apiPath}', { data: body }).then((res) => res.data)`
      }
      return `axios.${lowerMethod}('${apiPath}', body).then((res) => res.data)`
    case 'ky':
      if (method === 'DELETE') {
        return `ky.${lowerMethod}('${apiPath}', { json: body }).json()`
      }
      return `ky.${lowerMethod}('${apiPath}', { json: body }).json()`
  }
}

// ---- Query hook generation (GET requests) ----

function generateQueryHook(
  key: string,
  _ds: PageSchemaDataSource,
  apiPath: string,
  style: HooksStyle,
  apiClient: ApiClientStyle,
): string[] {
  const hookName = toHookName(key)
  const lines: string[] = []

  switch (style) {
    case 'hooks':
      lines.push(`export function ${hookName}() {`)
      lines.push(`  const [data, setData] = useState<unknown>(null)`)
      lines.push(`  const [isLoading, setIsLoading] = useState(true)`)
      lines.push(`  const [error, setError] = useState<Error | null>(null)`)
      lines.push('')
      lines.push(`  const fetchData = useCallback(async () => {`)
      lines.push(`    setIsLoading(true)`)
      lines.push(`    setError(null)`)
      lines.push(`    try {`)
      lines.push(`      const result = await ${fetcherExpression(apiPath, apiClient)}`)
      lines.push(`      setData(result)`)
      lines.push(`    } catch (err) {`)
      lines.push(`      setError(err instanceof Error ? err : new Error(String(err)))`)
      lines.push(`    } finally {`)
      lines.push(`      setIsLoading(false)`)
      lines.push(`    }`)
      lines.push(`  }, [])`)
      lines.push('')
      lines.push(`  useEffect(() => {`)
      lines.push(`    fetchData()`)
      lines.push(`  }, [fetchData])`)
      lines.push('')
      lines.push(`  return { data, isLoading, error, refetch: fetchData }`)
      lines.push(`}`)
      break

    case 'swr':
      lines.push(`export function ${hookName}() {`)
      lines.push(
        `  return useSWR('${apiPath}', (url: string) => ${fetcherExpression(apiPath, apiClient)})`,
      )
      lines.push(`}`)
      break

    case 'react-query':
      lines.push(`export function ${hookName}() {`)
      lines.push(`  return useQuery({`)
      lines.push(`    queryKey: ['${key}'],`)
      lines.push(
        `    queryFn: () => ${fetcherExpression(apiPath, apiClient)},`,
      )
      lines.push(`  })`)
      lines.push(`}`)
      break
  }

  return lines
}

// ---- Mutation hook generation (POST/PUT/PATCH/DELETE) ----

function generateMutationHook(
  key: string,
  _ds: PageSchemaDataSource,
  method: string,
  apiPath: string,
  style: HooksStyle,
  apiClient: ApiClientStyle,
): string[] {
  const hookName = toHookName(key)
  const lines: string[] = []

  // Find related query keys for cache invalidation
  // Convention: mutation hooks invalidate queries with similar names
  const relatedQueryKey = findRelatedQueryKey(key)

  switch (style) {
    case 'hooks':
      lines.push(`export function ${hookName}() {`)
      lines.push(`  const [isLoading, setIsLoading] = useState(false)`)
      lines.push(`  const [error, setError] = useState<Error | null>(null)`)
      lines.push('')
      lines.push(`  const mutate = useCallback(async (body?: unknown) => {`)
      lines.push(`    setIsLoading(true)`)
      lines.push(`    setError(null)`)
      lines.push(`    try {`)
      lines.push(`      const result = await ${mutationExpression(method, apiPath, apiClient)}`)
      lines.push(`      return result`)
      lines.push(`    } catch (err) {`)
      lines.push(`      const error = err instanceof Error ? err : new Error(String(err))`)
      lines.push(`      setError(error)`)
      lines.push(`      throw error`)
      lines.push(`    } finally {`)
      lines.push(`      setIsLoading(false)`)
      lines.push(`    }`)
      lines.push(`  }, [])`)
      lines.push('')
      lines.push(`  return { mutate, isLoading, error }`)
      lines.push(`}`)
      break

    case 'swr':
      lines.push(`export function ${hookName}() {`)
      lines.push(
        `  return useSWRMutation('${apiPath}', (_url: string, { arg: body }: { arg: unknown }) => ${mutationExpression(method, apiPath, apiClient)})`,
      )
      lines.push(`}`)
      break

    case 'react-query':
      lines.push(`export function ${hookName}() {`)
      lines.push(`  const queryClient = useQueryClient()`)
      lines.push(`  return useMutation({`)
      lines.push(
        `    mutationFn: (body: unknown) => ${mutationExpression(method, apiPath, apiClient)},`,
      )
      if (relatedQueryKey) {
        lines.push(`    onSuccess: () => {`)
        lines.push(
          `      queryClient.invalidateQueries({ queryKey: ['${relatedQueryKey}'] })`,
        )
        lines.push(`    },`)
      }
      lines.push(`  })`)
      lines.push(`}`)
      break
  }

  return lines
}

/**
 * Heuristic: find a related query key for cache invalidation.
 * "createUser" → "userList", "deleteUser" → "userList"
 * Falls back to undefined if no pattern matches.
 */
function findRelatedQueryKey(mutationKey: string): string | undefined {
  // Strip common mutation prefixes
  const prefixes = ['create', 'update', 'delete', 'remove', 'add', 'edit', 'save']
  for (const prefix of prefixes) {
    if (mutationKey.toLowerCase().startsWith(prefix)) {
      const entity = mutationKey.slice(prefix.length)
      if (entity) {
        // Return a camelCase list key (e.g. "userList")
        return entity.charAt(0).toLowerCase() + entity.slice(1) + 'List'
      }
    }
  }
  return undefined
}
