// ============================================================
// Types Generator — Generate TypeScript type definitions from PageSchema
// ============================================================

import type { PageSchema, PageSchemaTreeNode } from '@neuron-ui/metadata'
import { toPageComponentName, toPascalCase, parseApiString } from '../utils/naming'

/**
 * Generate a types file (.types.ts) from a PageSchema.
 * Produces:
 *   - An interface for each data source response
 *   - Column type definitions for NDataTable nodes
 *   - A top-level page data interface aggregating all data sources
 */
export function generateTypesFile(schema: PageSchema): string {
  const pageName = toPageComponentName(schema.page.name)
  const dataSources = schema.dataSources ?? {}
  const entries = Object.entries(dataSources)

  const lines: string[] = []

  // File header
  lines.push(`// ${pageName}.types.ts`)
  lines.push(`// Auto-generated by @neuron-ui/codegen — do not edit manually`)
  lines.push('')

  // Generate an interface for each data source
  for (const [key, ds] of entries) {
    const { method } = parseApiString(ds.api)
    const typeName = `${toPascalCase(key)}Data`

    if (method === 'GET') {
      // For GET endpoints, try to infer shape from table columns
      const columns = findColumnsForDataSource(key, schema.tree)
      if (columns.length > 0) {
        lines.push(`export interface ${toPascalCase(key)}Item {`)
        for (const col of columns) {
          lines.push(`  ${col.key}: unknown`)
        }
        lines.push(`}`)
        lines.push('')
        lines.push(`export type ${typeName} = ${toPascalCase(key)}Item[]`)
      } else {
        lines.push(`export type ${typeName} = Array<Record<string, unknown>>`)
      }
    } else {
      // For mutation endpoints, generate request body type
      if (ds.body && Object.keys(ds.body).length > 0) {
        lines.push(`export interface ${toPascalCase(key)}Payload {`)
        for (const field of Object.keys(ds.body)) {
          lines.push(`  ${field}: unknown`)
        }
        lines.push(`}`)
      } else {
        lines.push(`export type ${toPascalCase(key)}Payload = Record<string, unknown>`)
      }
    }
    lines.push('')
  }

  // Top-level page data interface
  if (entries.length > 0) {
    lines.push(`/** Aggregated page data shape */`)
    lines.push(`export interface ${pageName}Data {`)
    for (const [key, ds] of entries) {
      const { method } = parseApiString(ds.api)
      if (method === 'GET') {
        const columns = findColumnsForDataSource(key, schema.tree)
        if (columns.length > 0) {
          lines.push(`  ${key}: ${toPascalCase(key)}Item[]`)
        } else {
          lines.push(`  ${key}: Array<Record<string, unknown>>`)
        }
      }
    }
    lines.push(`}`)
    lines.push('')
  }

  return lines.join('\n')
}

// ---- Internal helpers ----

interface ColumnInfo {
  key: string
  label?: string
}

/**
 * Find NDataTable column definitions that are bound to the given dataSource key.
 */
function findColumnsForDataSource(
  dataSourceKey: string,
  nodes: PageSchemaTreeNode[],
): ColumnInfo[] {
  const columns: ColumnInfo[] = []

  function walk(node: PageSchemaTreeNode) {
    if (
      node.component === 'NDataTable' &&
      node.binding?.dataSource === dataSourceKey &&
      node.props?.columns &&
      Array.isArray(node.props.columns)
    ) {
      for (const col of node.props.columns) {
        if (typeof col === 'object' && col !== null) {
          const colObj = col as Record<string, unknown>
          columns.push({
            key: String(colObj.key ?? colObj.field ?? ''),
            label: colObj.label ? String(colObj.label) : undefined,
          })
        }
      }
    }
    if (node.children) {
      for (const child of node.children) {
        walk(child)
      }
    }
  }

  for (const node of nodes) {
    walk(node)
  }

  return columns
}
